var documenterSearchIndex = {"docs":
[{"location":"howtouse/#How-to-use","page":"How to use","title":"How to use","text":"","category":"section"},{"location":"howtouse/#Definition-of-the-pseudo-fermion-fields","page":"How to use","title":"Definition of the pseudo-fermion fields","text":"","category":"section"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"The pseudo-fermin field is defined as ","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"using Gaugefields\nusing LatticeDiracOperators\n\nNX = 4\nNY = 4\nNZ = 4\nNT = 4\nNwing = 1\nDim = 4\nNC = 3\n\nU = Initialize_4DGaugefields(NC,Nwing,NX,NY,NZ,NT,condition = \"cold\")\nx = Initialize_pseudofermion_fields(U[1],\"Wilson\")","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"Now, x is a pseudo fermion fields for Wilson Dirac operator.  The element of x is x[ic,ix,iy,iz,it,ialpha]. ic is an index of the color. ialpha is the internal degree of the gamma matrix. ","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"Then, the Wilson Dirac operator can be defined as ","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"params = Dict()\nparams[\"Dirac_operator\"] = \"Wilson\"\nparams[\"κ\"] = 0.141139\nparams[\"eps_CG\"] = 1.0e-8\nparams[\"verbose_level\"] = 2\n\nD = Dirac_operator(U,x,params)","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"If you want to get the Gaussian distributed pseudo-fermions, just do","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"gauss_distribution_fermion!(x)","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"Then, you can apply the Dirac operator to the pseudo-fermion fields. ","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"using LinearAlgebra\ny = similar(x)\nmul!(y,D,x)","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"And you can solve the equation D x = b like","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"solve_DinvX!(y,D,x)\nprintln(y[1,1,1,1,1,1])","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"If you want to see the convergence of the CG method, you can change the \"verbose_level\" in the Dirac operator. ","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"params[\"verbose_level\"] = 3\nD = Dirac_operator(U,x,params)\ngauss_distribution_fermion!(x)\nsolve_DinvX!(y,D,x)\nprintln(y[1,1,1,1,1,1])","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"The output is like ","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"bicg method\n1-th eps: 1742.5253056262081\n2-th eps: 758.2899742222573\n3-th eps: 378.7020470573924\n4-th eps: 210.17029515182503\n5-th eps: 118.00493128655506\n6-th eps: 63.31719669150997\n7-th eps: 36.18603541453448\n8-th eps: 21.593691953496077\n9-th eps: 16.02895509383768\n10-th eps: 12.920647360667004\n11-th eps: 9.532250164198402\n12-th eps: 5.708202470516758\n13-th eps: 3.1711913019834337\n14-th eps: 0.9672090407947617\n15-th eps: 0.14579004932559966\n16-th eps: 0.02467506197970277\n17-th eps: 0.005588563782732157\n18-th eps: 0.002285284357387675\n19-th eps: 5.147142014626153e-5\n20-th eps: 3.5632092739322066e-10\nConverged at 20-th step. eps: 3.5632092739322066e-10","category":"page"},{"location":"howtouse/#Other-operators","page":"How to use","title":"Other operators","text":"","category":"section"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"You can use the adjoint of the Dirac operator ","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"gauss_distribution_fermion!(x)\nsolve_DinvX!(y,D',x)\nprintln(y[1,1,1,1,1,1])","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"You can define the D^{\\dagger} D operator. ","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"DdagD = DdagD_operator(U,x,params)\ngauss_distribution_fermion!(x)\nsolve_DinvX!(y,DdagD,x) \nprintln(y[1,1,1,1,1,1])","category":"page"},{"location":"howtouse/#Other-Fermions","page":"How to use","title":"Other Fermions","text":"","category":"section"},{"location":"howtouse/#Staggared-Fermions","page":"How to use","title":"Staggared Fermions","text":"","category":"section"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"The Dirac operator of the staggered fermions is defined as ","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"x = Initialize_pseudofermion_fields(U[1],\"staggered\")\ngauss_distribution_fermion!(x)\nparams = Dict()\nparams[\"Dirac_operator\"] = \"staggered\"\nparams[\"mass\"] = 0.1\nparams[\"eps_CG\"] = 1.0e-8\nparams[\"verbose_level\"] = 2\nD = Dirac_operator(U,x,params)\n\ny = similar(x)\nmul!(y,D,x)\nprintln(y[1,1,1,1,1,1])\n\nsolve_DinvX!(y,D,x)\nprintln(y[1,1,1,1,1,1])","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"The \"tastes\" of the Staggered Fermion is defined in the action. ","category":"page"},{"location":"howtouse/#Domainwall-Fermions","page":"How to use","title":"Domainwall Fermions","text":"","category":"section"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"This package supports standard domainwall fermions.  The Dirac operator of the domainwall fermion is defined as ","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"L5 = 4\nx = Initialize_pseudofermion_fields(U[1],\"Domainwall\",L5=L5)\nprintln(\"x \", x.w[1][1,1,1,1,1,1])\ngauss_distribution_fermion!(x)\n\nparams = Dict()\nparams[\"Dirac_operator\"] = \"Domainwall\"\nparams[\"eps_CG\"] = 1.0e-16\nparams[\"MaxCGstep\"] = 3000\nparams[\"verbose_level\"] = 3\nparams[\"mass\"] = 0.1\nparams[\"L5\"] = L5\nD = Dirac_operator(U,x,params)\n\nprintln(\"x \", x[1,1,1,1,1,1,1])\ny = similar(x)\nsolve_DinvX!(y,D,x)\nprintln(\"y \", y[1,1,1,1,1,1,1])\n\nz = similar(x)\nmul!(z,D,y)\nprintln(\"z \", z[1,1,1,1,1,1,1])\n","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"The domainwall fermion is defined in 5D space. The element of x is x[ic,ix,iy,iz,it,ialpha,iL], where iL is an index on the five dimensional axis. ","category":"page"},{"location":"howtouse/#Fermion-Action","page":"How to use","title":"Fermion Action","text":"","category":"section"},{"location":"howtouse/#Wilson-Fermion","page":"How to use","title":"Wilson Fermion","text":"","category":"section"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"The action for pseudo-fermion is defined as ","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"\nNX = 4\nNY = 4\nNZ = 4\nNT = 4\nNwing = 1\nDim = 4\nNC = 3\n\nU = Initialize_4DGaugefields(NC,Nwing,NX,NY,NZ,NT,condition = \"cold\")\nx = Initialize_pseudofermion_fields(U[1],\"Wilson\")\ngauss_distribution_fermion!(x)\n\nparams = Dict()\nparams[\"Dirac_operator\"] = \"Wilson\"\nparams[\"κ\"] = 0.141139\nparams[\"eps_CG\"] = 1.0e-8\nparams[\"verbose_level\"] = 2\n\nD = Dirac_operator(U,x,params)\n\nparameters_action = Dict()\nfermi_action = FermiAction(D,parameters_action)\n\n","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"The fermion action with given pseudo-fermion fields is evaluated as ","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"Sfnew = evaluate_FermiAction(fermi_action,U,x)\nprintln(Sfnew)","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"The derivative of the fermion action dSf/dU can be calculated as ","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"UdSfdUμ = calc_UdSfdU(fermi_action,U,x)","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"The function calcUdSfdU calculates the U dSf/dU, You can also use ``` calcUdSfdU!(UdSfdUμ,fermi_action,U,x) ```","category":"page"},{"location":"howtouse/#Staggered-Fermion","page":"How to use","title":"Staggered Fermion","text":"","category":"section"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"In the case of the Staggered fermion, we can choose \"taste\".  The action is defined as ","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"x = Initialize_pseudofermion_fields(U[1],\"staggered\")\ngauss_distribution_fermion!(x)\nparams = Dict()\nparams[\"Dirac_operator\"] = \"staggered\"\nparams[\"mass\"] = 0.1\nparams[\"eps_CG\"] = 1.0e-8\nparams[\"verbose_level\"] = 2\nD = Dirac_operator(U,x,params)\n\nNf = 2\n\nprintln(\"Nf = $Nf\")\nparameters_action = Dict()\nparameters_action[\"Nf\"] = Nf\nfermi_action = FermiAction(D,parameters_action)\n\nSfnew = evaluate_FermiAction(fermi_action,U,x)\nprintln(Sfnew)\n\nUdSfdUμ = calc_UdSfdU(fermi_action,U,x)","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"This package uses the RHMC techniques. ","category":"page"},{"location":"howtouse/#Domainwall-Fermions-2","page":"How to use","title":"Domainwall Fermions","text":"","category":"section"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"In the case of the domainwall fermion, the action is defined as ","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":" L5 = 4\nx = Initialize_pseudofermion_fields(U[1],\"Domainwall\",L5 = L5)\ngauss_distribution_fermion!(x)\n\nparams = Dict()\nparams[\"Dirac_operator\"] = \"Domainwall\"\nparams[\"mass\"] = 0.1\nparams[\"L5\"] = L5\nparams[\"eps_CG\"] = 1.0e-19\nparams[\"verbose_level\"] = 2\nparams[\"method_CG\"] = \"bicg\"\nD = Dirac_operator(U,x,params)\n\nparameters_action = Dict()\nfermi_action = FermiAction(D,parameters_action)\n\nSfnew = evaluate_FermiAction(fermi_action,U,x)\nprintln(Sfnew)\n\nUdSfdUμ = calc_UdSfdU(fermi_action,U,x)","category":"page"},{"location":"howtouse/#Hybrid-Monte-Carlo-with-fermions","page":"How to use","title":"Hybrid Monte Carlo with fermions","text":"","category":"section"},{"location":"howtouse/#Wilson-Fermion-2","page":"How to use","title":"Wilson Fermion","text":"","category":"section"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"We show the HMC code with this package. ","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"using Gaugefields\nusing LinearAlgebra\nusing InteractiveUtils\nusing Random\n\nfunction MDtest!(gauge_action,U,Dim,fermi_action,η,ξ)\n    p = initialize_TA_Gaugefields(U) #This is a traceless-antihermitian gauge fields. This has NC^2-1 real coefficients. \n    Uold = similar(U)\n    substitute_U!(Uold,U)\n    MDsteps = 10\n    temp1 = similar(U[1])\n    temp2 = similar(U[1])\n    comb = 6\n    factor = 1/(comb*U[1].NV*U[1].NC)\n    numaccepted = 0\n    Random.seed!(123)\n\n    numtrj = 10\n    for itrj = 1:numtrj\n        @time accepted = MDstep!(gauge_action,U,p,MDsteps,Dim,Uold,fermi_action,η,ξ)\n        numaccepted += ifelse(accepted,1,0)\n\n        plaq_t = calculate_Plaquette(U,temp1,temp2)*factor\n        println(\"$itrj plaq_t = $plaq_t\")\n        println(\"acceptance ratio \",numaccepted/itrj)\n    end\nend\n\nfunction calc_action(gauge_action,U,p)\n    NC = U[1].NC\n    Sg = -evaluate_GaugeAction(gauge_action,U)/NC #evaluate_GaugeAction(gauge_action,U) = tr(evaluate_GaugeAction_untraced(gauge_action,U))\n    Sp = p*p/2\n    S = Sp + Sg\n    return real(S)\nend\n\n\nfunction MDstep!(gauge_action,U,p,MDsteps,Dim,Uold,fermi_action,η,ξ)\n    Δτ = 1/MDsteps\n    NC,_,NN... = size(U[1])\n    \n    gauss_distribution!(p)\n    \n    substitute_U!(Uold,U)\n    gauss_sampling_in_action!(ξ,U,fermi_action)\n    sample_pseudofermions!(η,U,fermi_action,ξ)\n    Sfold = real(dot(ξ,ξ))\n    println(\"Sfold = $Sfold\")\n\n    Sold = calc_action(gauge_action,U,p) + Sfold\n    println(\"Sold = \",Sold)\n\n    for itrj=1:MDsteps\n        U_update!(U,p,0.5,Δτ,Dim,gauge_action)\n\n        P_update!(U,p,1.0,Δτ,Dim,gauge_action)\n        P_update_fermion!(U,p,1.0,Δτ,Dim,gauge_action,fermi_action,η)\n\n        U_update!(U,p,0.5,Δτ,Dim,gauge_action)\n    end\n    Sfnew = evaluate_FermiAction(fermi_action,U,η)\n    println(\"Sfnew = $Sfnew\")\n    Snew = calc_action(gauge_action,U,p) + Sfnew\n    \n    println(\"Sold = $Sold, Snew = $Snew\")\n    println(\"Snew - Sold = $(Snew-Sold)\")\n\n    accept = exp(Sold - Snew) >= rand()\n\n    #ratio = min(1,exp(Snew-Sold))\n    if accept != true #rand() > ratio\n        substitute_U!(U,Uold)\n        return false\n    else\n        return true\n    end\nend\n\nfunction U_update!(U,p,ϵ,Δτ,Dim,gauge_action)\n    temps = get_temporary_gaugefields(gauge_action)\n    temp1 = temps[1]\n    temp2 = temps[2]\n    expU = temps[3]\n    W = temps[4]\n\n    for μ=1:Dim\n        exptU!(expU,ϵ*Δτ,p[μ],[temp1,temp2])\n        mul!(W,expU,U[μ])\n        substitute_U!(U[μ],W)\n        \n    end\nend\n\nfunction P_update!(U,p,ϵ,Δτ,Dim,gauge_action) # p -> p +factor*U*dSdUμ\n    NC = U[1].NC\n    temps = get_temporary_gaugefields(gauge_action)\n    dSdUμ = temps[end]\n    factor =  -ϵ*Δτ/(NC)\n\n    for μ=1:Dim\n        calc_dSdUμ!(dSdUμ,gauge_action,μ,U)\n        mul!(temps[1],U[μ],dSdUμ) # U*dSdUμ\n        Traceless_antihermitian_add!(p[μ],factor,temps[1])\n    end\nend\n\nfunction P_update_fermion!(U,p,ϵ,Δτ,Dim,gauge_action,fermi_action,η)  # p -> p +factor*U*dSdUμ\n    #NC = U[1].NC\n    temps = get_temporary_gaugefields(gauge_action)\n    UdSfdUμ = temps[1:Dim]\n    factor =  -ϵ*Δτ\n\n    calc_UdSfdU!(UdSfdUμ,fermi_action,U,η)\n\n    for μ=1:Dim\n        Traceless_antihermitian_add!(p[μ],factor,UdSfdUμ[μ])\n        #println(\" p[μ] = \", p[μ][1,1,1,1,1])\n    end\nend\n\nfunction test1()\n    NX = 4\n    NY = 4\n    NZ = 4\n    NT = 4\n    Nwing = 1\n    Dim = 4\n    NC = 3\n\n    U = Initialize_4DGaugefields(NC,Nwing,NX,NY,NZ,NT,condition = \"cold\")\n\n    gauge_action = GaugeAction(U)\n    plaqloop = make_loops_fromname(\"plaquette\")\n    append!(plaqloop,plaqloop')\n    β = 5.5/2\n    push!(gauge_action,β,plaqloop)\n    \n    show(gauge_action)\n\n    x = Initialize_pseudofermion_fields(U[1],\"Wilson\")\n\n\n    params = Dict()\n    params[\"Dirac_operator\"] = \"Wilson\"\n    params[\"κ\"] = 0.141139\n    params[\"eps_CG\"] = 1.0e-8\n    params[\"verbose_level\"] = 2\n    D = Dirac_operator(U,x,params)\n\n\n    parameters_action = Dict()\n    fermi_action = FermiAction(D,parameters_action)\n\n    y = similar(x)\n\n    \n    MDtest!(gauge_action,U,Dim,fermi_action,x,y)\n\nend\n\n\ntest1()","category":"page"},{"location":"howtouse/#Staggered-Fermion-2","page":"How to use","title":"Staggered Fermion","text":"","category":"section"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"if you want to use the Staggered fermions in HMC, the code is like: ","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"function test2()\n    NX = 4\n    NY = 4\n    NZ = 4\n    NT = 4\n    Nwing = 1\n    Dim = 4\n    NC = 3\n\n    U = Initialize_4DGaugefields(NC,Nwing,NX,NY,NZ,NT,condition = \"cold\")\n\n    gauge_action = GaugeAction(U)\n    plaqloop = make_loops_fromname(\"plaquette\")\n    append!(plaqloop,plaqloop')\n    β = 5.5/2\n    push!(gauge_action,β,plaqloop)\n    \n    show(gauge_action)\n\n    x = Initialize_pseudofermion_fields(U[1],\"staggered\")\n    gauss_distribution_fermion!(x)\n    params = Dict()\n    params[\"Dirac_operator\"] = \"staggered\"\n    params[\"mass\"] = 0.1\n    params[\"eps_CG\"] = 1.0e-8\n    params[\"verbose_level\"] = 2\n    D = Dirac_operator(U,x,params)\n    \n    Nf = 2\n    \n    println(\"Nf = $Nf\")\n    parameters_action = Dict()\n    parameters_action[\"Nf\"] = Nf\n    fermi_action = FermiAction(D,parameters_action)\n\n    y = similar(x)\n\n    \n    MDtest!(gauge_action,U,Dim,fermi_action,x,y)\n\nend\n","category":"page"},{"location":"howtouse/#HMC-with-fermions-with-STOUT-smearing","page":"How to use","title":"HMC with fermions with STOUT smearing","text":"","category":"section"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"We show the code of HMC with Wilson fermions with STOUT smearing. ","category":"page"},{"location":"howtouse/","page":"How to use","title":"How to use","text":"using Gaugefields\nusing LinearAlgebra\nusing LatticeDiracOperators\n\nfunction MDtest!(gauge_action,U,Dim,nn,fermi_action,η,ξ)\n    p = initialize_TA_Gaugefields(U) #This is a traceless-antihermitian gauge fields. This has NC^2-1 real coefficients. \n    Uold = similar(U)\n    dSdU = similar(U)\n    \n    substitute_U!(Uold,U)\n    MDsteps = 10\n    temp1 = similar(U[1])\n    temp2 = similar(U[1])\n    comb = 6\n    factor = 1/(comb*U[1].NV*U[1].NC)\n    numaccepted = 0\n    \n\n    numtrj = 100\n    for itrj = 1:numtrj\n        accepted = MDstep!(gauge_action,U,p,MDsteps,Dim,Uold,nn,dSdU,fermi_action,η,ξ)\n        numaccepted += ifelse(accepted,1,0)\n\n        plaq_t = calculate_Plaquette(U,temp1,temp2)*factor\n        println(\"$itrj plaq_t = $plaq_t\")\n        println(\"acceptance ratio \",numaccepted/itrj)\n    end\nend\n\nfunction calc_action(gauge_action,U,p)\n    NC = U[1].NC\n    Sg = -evaluate_GaugeAction(gauge_action,U)/NC #evaluate_GaugeAction(gauge_action,U) = tr(evaluate_GaugeAction_untraced(gauge_action,U))\n    Sp = p*p/2\n    S = Sp + Sg\n    return real(S)\nend\n\n\nfunction MDstep!(gauge_action,U,p,MDsteps,Dim,Uold,nn,dSdU,fermi_action,η,ξ)\n    \n\n    Δτ = 1/MDsteps\n    gauss_distribution!(p)\n\n    Uout,Uout_multi,_ = calc_smearedU(U,nn)\n    #Sold = calc_action(gauge_action,Uout,p)\n\n    substitute_U!(Uold,U)\n\n    gauss_sampling_in_action!(ξ,Uout,fermi_action)\n    sample_pseudofermions!(η,Uout,fermi_action,ξ)\n    Sfold = real(dot(ξ,ξ))\n    println(\"Sfold = $Sfold\")\n\n    Sold = calc_action(gauge_action,U,p) + Sfold\n    println(\"Sold = \",Sold)\n\n\n    for itrj=1:MDsteps\n        U_update!(U,p,0.5,Δτ,Dim,gauge_action)\n\n        P_update!(U,p,1.0,Δτ,Dim,gauge_action)\n        P_update_fermion!(U,p,1.0,Δτ,Dim,gauge_action,dSdU,nn,fermi_action,η)\n\n        U_update!(U,p,0.5,Δτ,Dim,gauge_action)\n    end\n\n    Uout,Uout_multi,_ = calc_smearedU(U,nn)\n    #Snew = calc_action(gauge_action,Uout,p)\n\n    Sfnew = evaluate_FermiAction(fermi_action,Uout,η)\n    println(\"Sfnew = $Sfnew\")\n    Snew = calc_action(gauge_action,U,p) + Sfnew\n    \n\n    println(\"Sold = $Sold, Snew = $Snew\")\n    println(\"Snew - Sold = $(Snew-Sold)\")\n    ratio = min(1,exp(Snew-Sold))\n    if rand() > ratio\n        substitute_U!(U,Uold)\n        return false\n    else\n        return true\n    end\nend\n\nfunction U_update!(U,p,ϵ,Δτ,Dim,gauge_action)\n    temps = get_temporary_gaugefields(gauge_action)\n    temp1 = temps[1]\n    temp2 = temps[2]\n    expU = temps[3]\n    W = temps[4]\n\n    for μ=1:Dim\n        exptU!(expU,ϵ*Δτ,p[μ],[temp1,temp2])\n        mul!(W,expU,U[μ])\n        substitute_U!(U[μ],W)\n        \n    end\nend\n\nfunction P_update!(U,p,ϵ,Δτ,Dim,gauge_action) # p -> p +factor*U*dSdUμ\n    NC = U[1].NC\n    temps = get_temporary_gaugefields(gauge_action)\n    dSdUμ = temps[end]\n    factor =  -ϵ*Δτ/(NC)\n\n    for μ=1:Dim\n        calc_dSdUμ!(dSdUμ,gauge_action,μ,U)\n        mul!(temps[1],U[μ],dSdUμ) # U*dSdUμ\n        Traceless_antihermitian_add!(p[μ],factor,temps[1])\n    end\nend\n\n\nfunction P_update_fermion!(U,p,ϵ,Δτ,Dim,gauge_action,dSdU,nn,fermi_action,η)  # p -> p +factor*U*dSdUμ\n    #NC = U[1].NC\n    temps = get_temporary_gaugefields(gauge_action)\n    UdSfdUμ = temps[1:Dim]\n    factor =  -ϵ*Δτ\n\n    Uout,Uout_multi,_ = calc_smearedU(U,nn)\n\n    for μ=1:Dim\n        calc_UdSfdU!(UdSfdUμ,fermi_action,Uout,η)\n        mul!(dSdU[μ],Uout[μ]',UdSfdUμ[μ])\n    end\n\n    dSdUbare = back_prop(dSdU,nn,Uout_multi,U) \n    \n\n    for μ=1:Dim\n        mul!(temps[1],U[μ],dSdUbare[μ]) # U*dSdUμ\n        Traceless_antihermitian_add!(p[μ],factor,temps[1])\n        #println(\" p[μ] = \", p[μ][1,1,1,1,1])\n    end\nend\n\nfunction test1()\n    NX = 4\n    NY = 4\n    NZ = 4\n    NT = 4\n    Nwing = 1\n    Dim = 4\n    NC = 3\n\n    U  =Initialize_Gaugefields(NC,Nwing,NX,NY,NZ,NT,condition = \"hot\")\n\n\n    gauge_action = GaugeAction(U)\n    plaqloop = make_loops_fromname(\"plaquette\")\n    append!(plaqloop,plaqloop')\n    β = 5.7/2\n    push!(gauge_action,β,plaqloop)\n\n    show(gauge_action)\n\n    L = [NX,NY,NZ,NT]\n    nn = CovNeuralnet()\n    ρ = [0.1]\n    layername = [\"plaquette\"]\n    st = STOUT_Layer(layername,ρ,L)\n    push!(nn,st)\n    #push!(nn,st)\n\n    x = Initialize_pseudofermion_fields(U[1],\"Wilson\")\n\n\n    params = Dict()\n    params[\"Dirac_operator\"] = \"Wilson\"\n    params[\"κ\"] = 0.141139\n    params[\"eps_CG\"] = 1.0e-8\n    params[\"verbose_level\"] = 2\n    D = Dirac_operator(U,x,params)\n\n\n    parameters_action = Dict()\n    fermi_action = FermiAction(D,parameters_action)\n\n    y = similar(x)\n    \n\n    MDtest!(gauge_action,U,Dim,nn,fermi_action,x,y)\n\nend\n\n\ntest1()","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = LatticeDiracOperators","category":"page"},{"location":"#LatticeDiracOperators","page":"Home","title":"LatticeDiracOperators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for LatticeDiracOperators.","category":"page"},{"location":"#Abstract","page":"Home","title":"Abstract","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is a package for lattice QCD codes. Treating pseudo-femrion fields with various lattice Dirac operators, fermion actions with MPI.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"./LQCDjl_block.png\" width=300>","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package will be used in LatticeQCD.jl. ","category":"page"},{"location":"#What-this-package-can-do:","page":"Home","title":"What this package can do:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Constructing actions and its derivative for Staggered Fermion with 1-8 tastes (with the use of the rational HMC technique)\nConstructing actions and its derivative for Wilson Fermion\nConstructing actions and its derivative for Standard Domainwall Fermion (Experimental. not well tested)\nHybrid Monte Carlo method with fermions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"With the use of the Gaugefields.jl, we can also do the HMC with STOUT smearing. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package will be used in LatticeQCD.jl.  This package uses Gaugefields.jl.  This package can be regarded as the additional package of the Gaugefields.jl to treat with Lattice fermions (pseudo- fermions). ","category":"page"},{"location":"#Install","page":"Home","title":"Install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"add LatticeDiracOperators.jl","category":"page"}]
}
